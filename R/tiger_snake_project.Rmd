---
title: "Tiger Snake Variant Identification - Part 1"
author: "Chelsea Matthews"
date: "3 February 2020"
output: 
  html_document:
      code_folding: "show"
      number_sections: TRUE
      toc: TRUE
      toc_float: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
											results = "asis",
											message = FALSE, warning = FALSE,
											error = FALSE)
```

#Introduction and Setup

Required Packages are loaded. 

```{r loadPackages}
library(knitr)
library(tidyverse)
library(ngsReports)
library(magrittr)
library(pander)
library(dplyr)
library(SeqGSEA)
library(GenomicFeatures)
library(vcfR)
library(rtracklayer)
library(VariantAnnotation)
library(SeqArray)
library(gdsfmt)
library(plyr)
library(Repitools)
library(kableExtra)
library(Biostrings)
library(rnaseqWrapper)
library(seqinr)
library(Rsamtools)
library(biomaRt)
library(AnnotationHub)
```

## Data description

**Genes of Interest**

Three fasta files containing genes associated with growth, lipid metabolism and pigmentation were provided. The genes were listed as Human Ensembl IDs. 
<br><br>
**Illumina Reads**

150 bp paired-end Illumina NovaSeq reads from an Island tiger snake were provided at approximately 75x coverage prior to quality control. 
<br><br>
**Notechis scutatus Assembly**

The Notechis scutatus assembly and associated files (RefSeq Accession Number GCF_900518725.1) were also used. 

## Project Aims
1. Identify variants in the Island tiger snake compared with Notechis scutatus. In particular, identify high confidence variants located within a selection of supplied genes of interest that are likely to impact amino acid expression as well as high confidence variants possibly located in the promoter regions (15000 bp upstream) of these genes. 
2. Compare variant density between the provided genes of interest with the variant density of the remaining annotated genes in the Notechis scutatus assembly.
3. Identify genes of interest with the greatest density of non-synonymous variants in their CDS regions (See Part 2).

# Pre-processing
Pre-processing steps were implemented in Snakemake on Phoenix except where noted otherwise. 
Snakemake is a workflow management system where each step in a pipeline is contained within a "rule" with defined inputs and outputs. The Snakefile containing all rules will be supplied separately as well as rule-graphs generated by Snakemake showing how the defined rules are applied to process the raw data into variant calls for further analysis in R. 

**Summary of steps**

- Illumina reads trimmed with cutadapt 
- Illumina reads aligned to Notechis scutatus assembly (GenBank: GCA_900518725.1)
- .bam files processed to be compatible with GATK
- Variants called with BCFtools
- Variants called with GATK 
- Variants called with Freebayes 
- All variants filtered using vcftools for Depth >= 5 
- Variants located within genes of interest identified
- Variants located up to 15000bp upstream of genes of interest identified
- All variants loaded into R


## Quality Control

```{r echo=FALSE}
fileDir <- "~/fast_dir/snakes/0_rawData/FastQC"
files <- list.files(fileDir, pattern = "fastqc.zip$", full.names = TRUE)
fdl_raw <- getFastqcData(files)

fileDir <- "~/fast_dir/snakes/1_trimmedData/FastQC"
files <- list.files(fileDir, pattern = "fastqc.zip$", full.names = TRUE)
fdl_trim <- getFastqcData(files)
```

Data was paired end, `r ngsReports::Basic_Statistics(fdl_raw)[1, 4]` bp reads with a total of `r ngsReports::Basic_Statistics(fdl_raw)[1, 2]` read pairs prior to trimming. The FastQC report indicated that the reads were generally of very high quality but that poly-G sequences were over-represented in the reverse reads. This is a common artefact of NovaSeq two-colour chemistry. 
Using cutadapt, poly-G tails were trimmed. Cutadapt then removed any reads (and their pair) of less than 50bp in length. 

Following trimming, `r ngsReports::Basic_Statistics(fdl_trim)[1, 2]` read pairs remained and the data was suitable for further processing. 

## Alignment
The reads were then aligned to the Notechis scutatus assembly using bwa-mem, the resulting .bam file was re-formatted with a number of tools to ensure its compatibility with GATK and variants were then called using GATK, Freebayes and BCFtools (as shown in the rulegraphs provided) resulting in three separate .vcf files. 

## Subset .vcf files
To enable the importation of variants into R for further processing, the .vcf files were subset using .bed files. The .bed files were generated as detailed below. 

Ensembl Gene IDs of the genes of interest were extracted from the fasta files provided using:

```{bash eval=FALSE}
grep '^>' Growth_genes_oneline_short.fa | sed 's/^.//' > Growth_genes_ensembl.txt
grep '^>' Pigmentation_oneline_short.fa | sed 's/^.//' > Pigmentation_ensembl.txt
grep '^>' Lipid_metabolism_oneline_short.fa | sed 's/^.//' > Lipid_metabolism_ensembl.txt
```

A txdb object is created from the Notechis scutatus .gff to get the location of the genes of interest

```{r}
txdb <- makeTxDbFromGFF("~/fast_dir/snakes/reference/GCF_900518725.1_TS10Xv2-PRI_genomic.gff", format="gff")
genes <- genes(txdb)
```

Ensembl Gene IDs were converted to Gene Symbols so that they match the annotation of the Notechis scutatus assembly. Gene coordinates were then extracted from the .gff and .bed files were created.

```{r results='hide'}
#Annotation Hub is loaded using the species "Homo sapiens" to match the provided ensembl IDs
ah <- AnnotationHub()
ah %>%
  subset(species == "Homo sapiens") %>%
  subset(dataprovider == "Ensembl") %>%
  subset(rdataclass == "EnsDb")
ensDb <- ah[["AH64923"]]
genesGR <- genes(ensDb)
hsEns2Sym <- mcols(genesGR) %>% 
  as_tibble() %>% 
  dplyr::select(gene_id, gene_name)

#Genes of interest are read in
pigmentation_genes <- read.table("~/fast_dir/snakes/targets/Pigmentation_ensembl.txt") %>%
  set_colnames("gene_id") %>%
  as_tibble()
growth_genes <- read.table("~/fast_dir/snakes/targets/Growth_genes_ensembl.txt") %>%
  set_colnames("gene_id") %>%
  as_tibble()
lipid_genes <- read.table("~/fast_dir/snakes/targets/Lipid_metabolism_ensembl.txt") %>%
  set_colnames("gene_id") %>%
  as_tibble()

#Ensembl Gene IDs are converted to Gene Symbols
pigmentation_genes <- pigmentation_genes %>% left_join(hsEns2Sym)
growth_genes <- growth_genes %>% left_join(hsEns2Sym)
lipid_genes <- lipid_genes %>% left_join(hsEns2Sym)

#Create gene subsets using gene locations from txdb object. 
pigmentation_set <- subset(genes, gene_id %in% pigmentation_genes$gene_name)
growth_set <- subset(genes, gene_id %in% growth_genes$gene_name)
lipid_set <- subset(genes, gene_id %in% lipid_genes$gene_name)

#Export gene subset to a .bed file
export.bed(pigmentation_set, "~/fast_dir/snakes/targets/pigmentationg.bed")
export.bed(growth_set, "~/fast_dir/snakes/targets/growthg.bed")
export.bed(lipid_set, "~/fast_dir/snakes/targets/lipidg.bed")

```

Not all of the supplied genes of interest were present in the Notechis scutatus assembly. The table below summarises the number of genes identified. 

```{r echo = FALSE}
foundGenes <- matrix(c(nrow(growth_genes),
                       length(growth_set),
                       nrow(lipid_genes),
                       length(lipid_set),
                       nrow(pigmentation_genes),
                       length(pigmentation_set)),
                    nrow=2,
                    dimnames = list(c("Supplied Genes",
                                      "Genes Present"),
                                    c("Growth",
                                      "Lipid Metabolism",
                                      "Pigmentation")))

kable(foundGenes) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

.bed files describing the promoters of each gene of interest (15 kbp upstream) were also required and were generated in bash using the following commands: 

```{bash eval=FALSE}
awk '{if($2<15000) {print $1,'1',$2,$4,$5,$6;} else print $1, $2-15000,$2,$4,$5,$6}' OFS='\t' targets/growthg.bed > targets/growthp.bed

awk '{if($2<15000) {print $1,'1',$2,$4,$5,$6;} else print $1, $2-15000,$2,$4,$5,$6}' OFS='\t' targets/lipidg.bed > targets/lipidp.bed

awk '{if($2<15000) {print $1,'1',$2,$4,$5,$6;} else print $1, $2-15000,$2,$4,$5,$6}' OFS='\t' targets/pigmentationg.bed > targets/pigmentationp.bed

```

The resulting .bed files were then intersected with the .vcf files from each variant caller to generate subsets of variants for each group of genes and each variant caller. 

# R Processing

## Read in .vcf subset files

The resulting .vcf files are converted first to .gds files and are then read in as dataframes. This is demonstrated below for the freebayes growth genes. Code for the remaining files has been omitted.   
Note that the ##INFO=<ID=MQ... header line was removed from the BCFtools .vcf files as the Average Mapping Quality field was not recognised by the tool used for the conversion and it was not necessary for further analysis.

```{r results = 'hide'}
wd <- file.path("~/fast_dir/snakes/4_subset")
file.exists(wd)

gdsPath <- file.path(wd, "gds", "freebayes_growthg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  dir.create(dirname(gdsPath))
  file.path(wd, "vcf", "freebayes_growthg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_fgg<- seqOpen(gdsPath, readonly = FALSE)

df_fgg <- tibble(
    seqGetData(gds_fgg,"variant.id"),
    seqGetData(gds_fgg, "position"),
    seqGetData(gds_fgg, "chromosome"),
    seqGetData(gds_fgg, "allele"),
    seqGetData(gds_fgg, "annotation/qual"),
    seqGetData(gds_fgg, "annotation/info/DP"))
```

```{r echo=FALSE}
#naming convention for gds objects following the underscore (see above)
# first position = initial of snp caller used
# second position = initial of gene type (growth, lipids, pigmentation)
# third position = initial indicating gene or promoter

gdsPath <- file.path(wd, "gds", "freebayes_growthp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "freebayes_growthp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_fgp <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "freebayes_lipidg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "freebayes_lipidg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_flg <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "freebayes_lipidp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "freebayes_lipidp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_flp <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "freebayes_pigmentationg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "freebayes_pigmentationg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_fpg <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "freebayes_pigmentationp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "freebayes_pigmentationp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_fpp <- seqOpen(gdsPath, readonly = FALSE)

```


```{r echo=FALSE}
gdsPath <- file.path(wd, "gds", "gatk_growthg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  dir.create(dirname(gdsPath))
  file.path(wd, "vcf", "gatk_growthg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_ggg<- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "gatk_growthp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "gatk_growthp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_ggp <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "gatk_lipidg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "gatk_lipidg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_glg <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "gatk_lipidp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "gatk_lipidp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_glp <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "gatk_pigmentationg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "gatk_pigmentationg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_gpg <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "gatk_pigmentationp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "gatk_pigmentationp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_gpp <- seqOpen(gdsPath, readonly = FALSE)

```


```{bash echo=FALSE, eval=FALSE}
sed -i '52439d' 4_subset/vcf/bcftools_*.vcf
```

```{r echo=FALSE}
gdsPath <- file.path(wd, "gds", "bcftools_growthg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  dir.create(dirname(gdsPath))
  file.path(wd, "vcf", "bcftools_growthg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_bgg<- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "bcftools_growthp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "bcftools_growthp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_bgp <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "bcftools_lipidg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "bcftools_lipidg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_blg <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "bcftools_lipidp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "bcftools_lipidp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_blp <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "bcftools_pigmentationg.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "bcftools_pigmentationg.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_bpg <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "bcftools_pigmentationp.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  file.path(wd, "vcf", "bcftools_pigmentationp.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gds_bpp <- seqOpen(gdsPath, readonly = FALSE)
```


```{r echo=FALSE}

df_ggg <- tibble(
    seqGetData(gds_ggg,"variant.id"),
    seqGetData(gds_ggg, "position"),
    seqGetData(gds_ggg, "chromosome"),
    seqGetData(gds_ggg, "allele"),
    seqGetData(gds_ggg, "annotation/qual"),
    seqGetData(gds_ggg, "annotation/info/DP"))

df_ggp <- tibble(
    seqGetData(gds_ggp,"variant.id"),
    seqGetData(gds_ggp, "position"),
    seqGetData(gds_ggp, "chromosome"),
    seqGetData(gds_ggp, "allele"),
    seqGetData(gds_ggp, "annotation/qual"),
    seqGetData(gds_ggp, "annotation/info/DP"))

df_gpg <- tibble(
    seqGetData(gds_gpg,"variant.id"),
    seqGetData(gds_gpg, "position"),
    seqGetData(gds_gpg, "chromosome"),
    seqGetData(gds_gpg, "allele"),
    seqGetData(gds_gpg, "annotation/qual"),
    seqGetData(gds_gpg, "annotation/info/DP"))

df_gpp <- tibble(
    seqGetData(gds_gpp,"variant.id"),
    seqGetData(gds_gpp, "position"),
    seqGetData(gds_gpp, "chromosome"),
    seqGetData(gds_gpp, "allele"),
    seqGetData(gds_gpp, "annotation/qual"),
    seqGetData(gds_gpp, "annotation/info/DP"))

df_glg <- tibble(
    seqGetData(gds_glg,"variant.id"),
    seqGetData(gds_glg, "position"),
    seqGetData(gds_glg, "chromosome"),
    seqGetData(gds_glg, "allele"),
    seqGetData(gds_glg, "annotation/qual"),
    seqGetData(gds_glg, "annotation/info/DP"))

df_glp <- tibble(
    seqGetData(gds_glp,"variant.id"),
    seqGetData(gds_glp, "position"),
    seqGetData(gds_glp, "chromosome"),
    seqGetData(gds_glp, "allele"),
    seqGetData(gds_glp, "annotation/qual"),
    seqGetData(gds_glp, "annotation/info/DP"))

```

```{r echo=FALSE}

df_fgp <- tibble(
    seqGetData(gds_fgp,"variant.id"),
    seqGetData(gds_fgp, "position"),
    seqGetData(gds_fgp, "chromosome"),
    seqGetData(gds_fgp, "allele"),
    seqGetData(gds_fgp, "annotation/qual"),
    seqGetData(gds_fgp, "annotation/info/DP"))

df_fpg <- tibble(
    seqGetData(gds_fpg,"variant.id"),
    seqGetData(gds_fpg, "position"),
    seqGetData(gds_fpg, "chromosome"),
    seqGetData(gds_fpg, "allele"),
    seqGetData(gds_fpg, "annotation/qual"),
    seqGetData(gds_fpg, "annotation/info/DP"))

df_fpp <- tibble(
    seqGetData(gds_fpp,"variant.id"),
    seqGetData(gds_fpp, "position"),
    seqGetData(gds_fpp, "chromosome"),
    seqGetData(gds_fpp, "allele"),
    seqGetData(gds_fpp, "annotation/qual"),
    seqGetData(gds_fpp, "annotation/info/DP"))

df_flg <- tibble(
    seqGetData(gds_flg,"variant.id"),
    seqGetData(gds_flg, "position"),
    seqGetData(gds_flg, "chromosome"),
    seqGetData(gds_flg, "allele"),
    seqGetData(gds_flg, "annotation/qual"),
    seqGetData(gds_flg, "annotation/info/DP"))

df_flp <- tibble(
    seqGetData(gds_flp,"variant.id"),
    seqGetData(gds_flp, "position"),
    seqGetData(gds_flp, "chromosome"),
    seqGetData(gds_flp, "allele"),
    seqGetData(gds_flp, "annotation/qual"),
    seqGetData(gds_flp, "annotation/info/DP"))
```

```{r echo=FALSE}
df_bgg <- tibble(
    seqGetData(gds_bgg,"variant.id"),
    seqGetData(gds_bgg, "position"),
    seqGetData(gds_bgg, "chromosome"),
    seqGetData(gds_bgg, "allele"),
    seqGetData(gds_bgg, "annotation/qual"),
    seqGetData(gds_bgg, "annotation/info/DP"))

df_bgp <- tibble(
    seqGetData(gds_bgp,"variant.id"),
    seqGetData(gds_bgp, "position"),
    seqGetData(gds_bgp, "chromosome"),
    seqGetData(gds_bgp, "allele"),
    seqGetData(gds_bgp, "annotation/qual"),
    seqGetData(gds_bgp, "annotation/info/DP"))

df_bpg <- tibble(
    seqGetData(gds_bpg,"variant.id"),
    seqGetData(gds_bpg, "position"),
    seqGetData(gds_bpg, "chromosome"),
    seqGetData(gds_bpg, "allele"),
    seqGetData(gds_bpg, "annotation/qual"),
    seqGetData(gds_bpg, "annotation/info/DP"))

df_bpp <- tibble(
    seqGetData(gds_bpp,"variant.id"),
    seqGetData(gds_bpp, "position"),
    seqGetData(gds_bpp, "chromosome"),
    seqGetData(gds_bpp, "allele"),
    seqGetData(gds_bpp, "annotation/qual"),
    seqGetData(gds_bpp, "annotation/info/DP"))

df_blg <- tibble(
    seqGetData(gds_blg,"variant.id"),
    seqGetData(gds_blg, "position"),
    seqGetData(gds_blg, "chromosome"),
    seqGetData(gds_blg, "allele"),
    seqGetData(gds_blg, "annotation/qual"),
    seqGetData(gds_blg, "annotation/info/DP"))

df_blp <- tibble(
    seqGetData(gds_blp,"variant.id"),
    seqGetData(gds_blp, "position"),
    seqGetData(gds_blp, "chromosome"),
    seqGetData(gds_blp, "allele"),
    seqGetData(gds_blp, "annotation/qual"),
    seqGetData(gds_blp, "annotation/info/DP"))

df_list <- list(df_ggg,df_ggp,df_glg,df_glp,df_gpg,df_gpp,df_fgg,df_fgp,df_flg,df_flp,df_fpg,df_fpp,df_bgg,df_bgp,df_blg,df_blp,df_bpg,df_bpp)

colnames <- c("variant.id","start","scaffold","allele","QUAL","DP")
df_list <- (lapply(df_list, setNames, colnames))
```

```{r echo=FALSE}
seqClose(gds_ggg)
seqClose(gds_ggp)
seqClose(gds_glg)
seqClose(gds_glp)
seqClose(gds_gpg)
seqClose(gds_gpp)

seqClose(gds_fgg)
seqClose(gds_fgp)
seqClose(gds_flg)
seqClose(gds_flp)
seqClose(gds_fpg)
seqClose(gds_fpp)

seqClose(gds_bgg)
seqClose(gds_bgp)
seqClose(gds_blg)
seqClose(gds_blp)
seqClose(gds_bpg)
seqClose(gds_bpp)
```

All dataframes are added to a list and the columns of each dataframe are renamed.

Variants are stored in the data frame list in the positions shown below.

```{r echo=FALSE}
storageTable <- matrix(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18), nrow=6, dimnames = list(c("Growth Genes", "Growth Promoters", "Lipid Genes", "Lipid Promoters", "Pigmentation Genes", "Pigmentation Promoters"),c("GATK", "Freebayes", "BCFtools")))

kable(storageTable) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

The distribution of DP (coverage depth) for variants was then assessed to determine suitable filtering criteria. The table below shows quantiles for DP for the growth genes from each of the three variant callers. To interpret the table, a value of 15 in the 2.5% quantile column indicates that 2.5% of variants have a DP of less than 15. 

```{r echo=FALSE, message=FALSE}
#Distribution of variant depth for GATK growth gene variants
dist1 <- df_list[[1]]$DP %>% quantile(probs = c(0.025, 0.05, 0.25, 0.50, 0.75, 0.95, 0.975), na.rm = TRUE)

#Distribution of variant depth for Freebayes growth gene variants
dist2 <- df_list[[7]]$DP %>% quantile(probs = c(0.025, 0.05, 0.25, 0.50, 0.75, 0.95, 0.975), na.rm = TRUE)

#Distribution of variant depth for BCFtools growth gene variants
dist3 <- df_list[[13]]$DP %>% quantile(probs = c(0.025, 0.05, 0.25, 0.50, 0.75, 0.95, 0.975), na.rm = TRUE)

distTable <- matrix(c(dist1[1], dist2[1], dist3[1],
                      dist1[2], dist2[2], dist3[2],
                      dist1[3], dist2[3], dist3[3],
                      dist1[4], dist2[4], dist3[4],
                      dist1[5], dist2[5], dist3[5],
                      dist1[6], dist2[6], dist3[6],
                      dist1[7], dist2[7], dist3[7]),
                    nrow=3,
                    dimnames = list(c("GATK growth genes",
                                      "Freebayes growth genes",
                                      "BCFtools growth genes"), 
                                    c("2.5%",
                                      "5%",
                                      "25%",
                                      "50%",
                                      "75%",
                                      "95%",
                                      "97.5%")))
kable(distTable) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

Based on these quantiles, variants with DP less than 15 and greater than 85 are filtered out of all datasets.  

```{r}
myFilter <- function(index) {
  dplyr::filter(df_list[[index]], DP >= 15 & DP <= 85)
}
df_list <- lapply(1:18, FUN=myFilter)

```

A summary of the number of variants remaining for each variant caller and each genome region post-filtering can be seen below. 

```{r echo=FALSE}
numVariants <- matrix(c(nrow(df_list[[1]]),nrow(df_list[[2]]),
                    nrow(df_list[[3]]),nrow(df_list[[4]]),
                    nrow(df_list[[5]]),nrow(df_list[[6]]),
                    nrow(df_list[[7]]),nrow(df_list[[8]]),
                    nrow(df_list[[9]]),nrow(df_list[[10]]),
                    nrow(df_list[[11]]),nrow(df_list[[12]]),
                    nrow(df_list[[13]]),nrow(df_list[[14]]),
                    nrow(df_list[[15]]),nrow(df_list[[16]]),
                    nrow(df_list[[17]]),nrow(df_list[[18]])),
                    nrow=6, dimnames = list(c("Growth Genes",
                    "Growth Promoters", "Lipid Genes", "Lipid Promoters",
                    "Pigmentation Genes", "Pigmentation Promoters")
                    ,c("GATK","Freebayes", "BCFtools")))

kable(numVariants) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

## Identify High Confidence Variants

High confidence variants are defined as those called by all three variant callers. Specifically, variants at the same position on the same scaffold with the same reference and alternative allele reported. To identify all variants accurately, variants with two alternative alleles are split into two separate rows before obtaining the intersection of the three sets of variants.

```{r}
#Split rows with two alternative alleles into two separate rows
myRowSplitter <- function(index) {
  alts <- subset(df_list[[index]], str_count(allele, ",") > 1)
  df_list[[index]] <- df_list[[index]][(str_count(df_list[[index]]$allele, ",") == 1),]
  alts <- alts[rep(seq_len(nrow(alts)), each = 2),]
  count = 1
  while(count <= nrow(alts)){
    str <- strsplit(alts[[count,4]], ",")
    alts[count,'allele'] <- paste(str[[1]][1], str[[1]][2], sep = ",") 
    alts[count+1,'allele'] <- paste(str[[1]][1], str[[1]][3], sep = ",")
    count = count + 2
  }
  df_list[[index]] <- rbind(df_list[[index]],alts)  
}

df_list <- lapply(1:18, FUN=myRowSplitter)

#make a new temporary column (start+scaffold+allele) 
myUnite <- function(index) {
  unite(df_list[[index]], "start_scaff_all", start:allele, remove=FALSE)
}
df_list <- lapply(1:18, FUN=myUnite)

#intersect based on the start+scaff+all column to get high confidence variants
#variants in genes
df_high_growth_g <- match_df(match_df(df_list[[1]], df_list[[7]], on="start_scaff_all"),df_list[[13]], on="start_scaff_all")

df_high_lipid_g <- match_df(match_df(df_list[[3]], df_list[[9]], on="start_scaff_all"),df_list[[15]], on="start_scaff_all")

df_high_pigmentation_g <- match_df(match_df(df_list[[5]], df_list[[11]], on="start_scaff_all"),df_list[[17]], on="start_scaff_all")

#variants in promoters
df_high_growth_p <- match_df(match_df(df_list[[2]], df_list[[8]], on="start_scaff_all"),df_list[[14]], on="start_scaff_all")

df_high_lipid_p <- match_df(match_df(df_list[[4]], df_list[[10]], on="start_scaff_all"),df_list[[16]], on="start_scaff_all")

df_high_pigmentation_p <- match_df(match_df(df_list[[6]], df_list[[12]], on="start_scaff_all"),df_list[[18]], on="start_scaff_all")

#Make lists of high confidence variant dataframes
df_list_high_g <- list(df_high_growth_g, df_high_lipid_g, df_high_pigmentation_g)
df_list_high_p <- list(df_high_growth_p, df_high_lipid_p, df_high_pigmentation_p)

```

Variants located in the promoter regions of genes are not filtered any further. They are formatted and exported as .tsv files. 

```{r eval=FALSE}
#Formatting promoter variant dataframes
myFormatPromoter <- function(index) {
  df_list_high_p[[index]] <- separate(df_list_high_p[[index]], "allele", into=c("ref", "alt"), extra="merge")
  df_list_high_p[[index]] <- mutate(df_list_high_p[[index]], end = (start+nchar(ref))-1)
  df_list_high_p[[index]] <- subset(df_list_high_p[[index]], select = -c(start_scaff_all,QUAL,DP))
  df_list_high_p[[index]] <- df_list_high_p[[index]][,c(3, 2, 6, 4, 5)]
}

df_list_high_p <- lapply(1:3, FUN=myFormatPromoter)

#Writing .tsv files
write_tsv(df_list_high_p[[1]], "~/fast_dir/snakes/results/Growth_promoter_variants.tsv", append=FALSE, col_names=TRUE)
write_tsv(df_list_high_p[[2]], "~/fast_dir/snakes/results/LipidMetabolism_promoter_variants.tsv", append=FALSE, col_names=TRUE)
write_tsv(df_list_high_p[[3]], "~/fast_dir/snakes/results/Pigmentation_promoter_variants.tsv", append=FALSE, col_names=TRUE)
```

Variant density calculations (in a later section) require the total number of variants within the genes of interest.

```{r}
our_gene_variants <- (nrow(unique(df_list_high_g[[1]][c("start", "scaffold")]))
                      + nrow(unique(df_list_high_g[[2]][c("start", "scaffold")]))
                      + nrow(unique(df_list_high_g[[3]][c("start", "scaffold")])))
```

The three sets of high confidence variants (one each for Growth genes, Lipid Metabolism genes and Pigmentation genes) are formatted, converted into GRanges objects, and added to a list.

```{r}
#Format dataframes
myFormat <- function(index) {
  df_list_high_g[[index]] <- separate(df_list_high_g[[index]], "allele", into=c("ref", "alt"), extra="merge")
  df_list_high_g[[index]] <- mutate(df_list_high_g[[index]], end = (start+nchar(ref))-1)
  df_list_high_g[[index]] <- subset(df_list_high_g[[index]], select = -c(start_scaff_all,QUAL,DP))
}

df_list_high_g <- lapply(1:3, FUN=myFormat)

#Convert to a gRanges object
gr_high_growth_g <- makeGRangesFromDataFrame(df_list_high_g[[1]],
                         keep.extra.columns=TRUE,
                         ignore.strand=FALSE,
                         seqinfo=NULL,
                         seqnames.field=c("scaffold"),
                         start.field="start",
                         end.field=c("end"),
                         strand.field="strand",
                         starts.in.df.are.0based=FALSE)

gr_high_lipid_g <- makeGRangesFromDataFrame(df_list_high_g[[2]],
                         keep.extra.columns=TRUE,
                         ignore.strand=FALSE,
                         seqinfo=NULL,
                         seqnames.field=c("scaffold"),
                         start.field="start",
                         end.field=c("end"),
                         strand.field="strand",
                         starts.in.df.are.0based=FALSE)

gr_high_pigmentation_g <- makeGRangesFromDataFrame(df_list_high_g[[3]],
                         keep.extra.columns=TRUE,
                         ignore.strand=FALSE,
                         seqinfo=NULL,
                         seqnames.field=c("scaffold"),
                         start.field="start",
                         end.field=c("end"),
                         strand.field="strand",
                         starts.in.df.are.0based=FALSE)

#put GRanges objects in a list
gr_list <- list(gr_high_growth_g, gr_high_lipid_g, gr_high_pigmentation_g)

```

Of the high-confidence variants identified, not all are located within the coding sequence of a gene. All variants located within the coding sequences (CDS) are extracted and their position within the codon (first, second or third position) is determined. The phase of the CDS region, the start and end position of the CDS, the location of the SNP, and the strand on which the gene is located are used to determine this position. 

```{r}
#import gff and extract only CDS regions
gr_gff <- rtracklayer::import("~/fast_dir/snakes/reference/GCF_900518725.1_TS10Xv2-PRI_genomic.gff")
gr_gff_cds <- gr_gff[values(gr_gff)[ ,"type"] == "CDS"]

#Find which variants are in the cds
hits_high_growth_g_cds <- findOverlaps(gr_list[[1]], gr_gff_cds, type="any")
hits_high_lipid_g_cds <- findOverlaps(gr_list[[2]], gr_gff_cds, type="any")
hits_high_pigmentation_g_cds <- findOverlaps(gr_list[[3]], gr_gff_cds, type="any")

#Changing object types
df_gff_cds <- annoGR2DF(gr_gff_cds)
mat_hits_high_growth_g_cds <- as.matrix(hits_high_growth_g_cds)
mat_hits_high_lipid_g_cds <- as.matrix(hits_high_lipid_g_cds)
mat_hits_high_pigmentation_g_cds <- as.matrix(hits_high_pigmentation_g_cds)

#put matrix hits in a list
mat_list <- list(mat_hits_high_growth_g_cds, mat_hits_high_lipid_g_cds, mat_hits_high_pigmentation_g_cds)

#remove empty columns from df_gff_cds
df_gff_cds <- subset(df_gff_cds, select = c(chr,start,end,width,phase,strand,ID,protein_id))

#Add a blank column 
df_list_high_g[[1]]$codon_pos <- NA
df_list_high_g[[2]]$codon_pos <- NA
df_list_high_g[[3]]$codon_pos <- NA

#The function below determines the position of a variant within a codon based on its location, the start and end of the cds, the phase and the strand (- or +). The phase is counted from the start of the cds for the + strand and the end of the cds for the - strand.
myCodingVariants <- function(var,cds,index) {
  phase <- df_gff_cds[cds,"phase"]
  aStrand <- df_gff_cds[cds,"strand"]
  if(aStrand == "+") {
  if(phase == 0) {
          pos <- ((df_list_high_g[[index]][var,"start"]-(df_gff_cds[cds,"start"] - 1)) %% 3)
    return(pos)
    }
  else if(phase == 1) {
     pos <- ((df_list_high_g[[index]][var,"start"]-(df_gff_cds[cds,"start"])) %% 3)
    return(pos)
  }
  else {
     pos <- ((df_list_high_g[[index]][var,"start"]-(df_gff_cds[cds,"start"] - 2)) %% 3)
    return(pos)
  }
  }
else {
  if(phase == 0) {
    pos <- ((df_gff_cds[cds,"end"]-(df_list_high_g[[index]][var,"start"] - 1)) %% 3)
    return(pos+3)
    }
  else if(phase == 1) {
    pos <- ((df_gff_cds[cds,"end"]-(df_list_high_g[[index]][var,"start"])) %% 3)
    return(pos+3)
  }
  else {
    pos <- ((df_gff_cds[cds,"end"]-(df_list_high_g[[index]][var,"start"] - 2)) %% 3)
    return(pos+3)
  }
}
}

for (index in 1:3){
  for (row in 1:nrow(mat_list[[index]])) {            
  s <- myCodingVariants(mat_list[[index]][row,1],mat_list[[index]][row,2],index)
  df_list_high_g[[index]][mat_list[[index]][row,1],"codon_pos"] <- s
  }
}

#remove all rows with NA in the codon_pos column as they aren't located within the cds
for (index in 1:3){
  df_list_high_g[[index]] <- drop_na(df_list_high_g[[index]]) 
}
```

The table below details the number of variants identified within the CDS region by their strand and position in the codon. The majority of variants are located in the third position of codons where they are less likely to cause a change in amino acid expression. 

```{r echo=FALSE}
#table of variant positions on the + and - strands
positionTable <- matrix(c(nrow(subset(df_list_high_g[[1]],codon_pos==1)),
                          nrow(subset(df_list_high_g[[1]],codon_pos==2)),
                          nrow(subset(df_list_high_g[[1]],codon_pos==0)),
                          nrow(subset(df_list_high_g[[1]],codon_pos==4)),
                          nrow(subset(df_list_high_g[[1]],codon_pos==5)),
                          nrow(subset(df_list_high_g[[1]],codon_pos==3)),
                          nrow(subset(df_list_high_g[[2]],codon_pos==1)),
                          nrow(subset(df_list_high_g[[2]],codon_pos==2)),
                          nrow(subset(df_list_high_g[[2]],codon_pos==0)),
                          nrow(subset(df_list_high_g[[2]],codon_pos==4)),
                          nrow(subset(df_list_high_g[[2]],codon_pos==5)),
                          nrow(subset(df_list_high_g[[2]],codon_pos==3)),
                          nrow(subset(df_list_high_g[[3]],codon_pos==1)),
                          nrow(subset(df_list_high_g[[3]],codon_pos==2)),
                          nrow(subset(df_list_high_g[[3]],codon_pos==0)),
                          nrow(subset(df_list_high_g[[3]],codon_pos==4)),
                          nrow(subset(df_list_high_g[[3]],codon_pos==5)),
                          nrow(subset(df_list_high_g[[3]],codon_pos==3))),
                          nrow=6, dimnames = list(c("+First Position","+Second Position",
                                                    "+Third Position","-First Position", 
                                                    "-Second Position", "-Third Position"),
                                                  c("Growth Genes CDS", 
                                                    "Lipid Metabolism Genes CDS", 
                                                    "Pigmentation Genes CDS")))

kable(positionTable) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

```

## Identify variants that impact amino acid coding 

Only SNPs remain (no indels) in the set of high confidence variants located within the CDS regions. We then determine which of these variants impact amino acid coding by comparing the reference codon containing the SNP with the resulting codon obtained by substituting the reference with the alternative allele. If the substitution codes for a different amino acid, the mutation is considered non-synonymous. 

```{r eval = FALSE}

#Add extra column to df
df_list_high_g[[1]]$synonymous <- NA
df_list_high_g[[2]]$synonymous <- NA
df_list_high_g[[3]]$synonymous <- NA

#Index and load fasta file
indexFa("~/fast_dir/snakes/reference/GCF_900518725.1_TS10Xv2-PRI_genomic.fna")
fa = FaFile("~/fast_dir/snakes/reference/GCF_900518725.1_TS10Xv2-PRI_genomic.fna")

#Create a GRanges object to use to access the fasta file by sequence name
gr_fa <- as(seqinfo(fa), "GRanges")

#This function determines whether a SNP will impact amino acid coding. It extracts the codon that contains the SNP from the fasta file and compares it with the resulting codon with the alternative allele substituted in. If they are different, an n is printed in the synonymous column to indicate a non-synonymous mutation. If they are the same, a y is printed in the synonymous column to indicate a synonymous mutation. 
mySnpImpactPredictor <- function(scaff,location,codonPos,alt) {
  if(codonPos == 0) {
    refSeq <- getSeq(fa,gr_fa[scaff]) %>% substr(location-2,location) %>% paste(collapse="")
    altSeq <- DNAString(refSeq) %>% replaceLetterAt(at=3, alt) %>% paste(collapse="")
    if(GENETIC_CODE[[refSeq]] != GENETIC_CODE[[altSeq]]) {
      return("n")
    }
    else {
      return("y")
    }
  }
  else if(codonPos == 1) {
    refSeq <- getSeq(fa,gr_fa[scaff]) %>% substr(location,location+2) %>% paste(collapse="")
    altSeq <- DNAString(refSeq) %>% replaceLetterAt(at=1, alt) %>% paste(collapse="")
    if(GENETIC_CODE[[refSeq]] != GENETIC_CODE[[altSeq]]) {
      return("n")
    }
    else {
      return("y")
    }
  }
  else if(codonPos == 2) {
    refSeq <- getSeq(fa,gr_fa[scaff]) %>% substr(location-1,location+1) %>% paste(collapse="")
    altSeq <- DNAString(refSeq) %>% replaceLetterAt(at=2, alt) %>% paste(collapse="")
    if(GENETIC_CODE[[refSeq]] != GENETIC_CODE[[altSeq]]) {
      return("n")
    }
    else {
      return("y")
    }
  }
  else if(codonPos == 3) {
        refSeq <- getSeq(fa,gr_fa[scaff]) %>% substr(location,location+2) %>% DNAString() %>% reverseComplement() %>% paste(collapse="")
        alt <- DNAString(alt) %>% reverseComplement() %>% paste(collapse="")
    altSeq <- DNAString(refSeq) %>% replaceLetterAt(at=3, alt) %>% paste(collapse="")
    if(GENETIC_CODE[[refSeq]] != GENETIC_CODE[[altSeq]]) {
      return("n")
    }
    else {
      return("y")
    }
  }
    else if(codonPos == 4) {
        refSeq <- getSeq(fa,gr_fa[scaff]) %>% substr(location-2,location) %>% DNAString() %>% reverseComplement() %>% paste(collapse="")
        alt <- DNAString(alt) %>% reverseComplement() %>% paste(collapse="")
    altSeq <- DNAString(refSeq) %>% replaceLetterAt(at=1, alt) %>% paste(collapse="")
    if(GENETIC_CODE[[refSeq]] != GENETIC_CODE[[altSeq]]) {
      return("n")
    }
    else {
      return("y")
    }
    }
      else {
        refSeq <- getSeq(fa,gr_fa[scaff]) %>% substr(location-1,location+1) %>% DNAString() %>% reverseComplement() %>% paste(collapse="")
        alt <- DNAString(alt) %>% reverseComplement() %>% paste(collapse="")
    altSeq <- DNAString(refSeq) %>% replaceLetterAt(at=2, alt) %>% paste(collapse="")
    if(GENETIC_CODE[[refSeq]] != GENETIC_CODE[[altSeq]]) {
      return("n")
    }
    else {
      return("y")
    }
    }
}

for (index in 1:3){
  for (row in 1:nrow(df_list_high_g[[index]])) {            
  s <- mySnpImpactPredictor(df_list_high_g[[index]][[row,"scaffold"]], df_list_high_g[[index]][[row,"start"]], df_list_high_g[[index]][[row,"codon_pos"]],df_list_high_g[[index]][[row,"alt"]])
  df_list_high_g[[index]][row,"synonymous"] <- s
  }
}

```

```{r dataProcess, cache=TRUE, eval=FALSE, echo=FALSE}
save(df_list_high_g, file="~/fast_dir/snakes/HighConfidenceVariants.RData")
```
 
```{r echo=FALSE}
load('~/fast_dir/snakes/HighConfidenceVariants.RData')
```
 
The table below details the number of non-synonymous mutations for each of the the three positions in the codon and the strand on which the containing gene lies.

Synonymous variants are removed from the dataset and the remaining variants are saved to .tsv files. 

```{r echo=FALSE}
synonymousMut <- matrix(c(nrow(subset(df_list_high_g[[1]],codon_pos==1 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[1]],codon_pos==2 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[1]],codon_pos==0 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[1]],codon_pos==4 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[1]],codon_pos==5 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[1]],codon_pos==3 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[2]],codon_pos==1 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[2]],codon_pos==2 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[2]],codon_pos==0 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[2]],codon_pos==4 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[2]],codon_pos==5 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[2]],codon_pos==3 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[3]],codon_pos==1 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[3]],codon_pos==2 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[3]],codon_pos==0 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[3]],codon_pos==4 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[3]],codon_pos==5 & synonymous=="n")),
                          nrow(subset(df_list_high_g[[3]],codon_pos==3 & synonymous=="n"))),
                          nrow=6, dimnames = list(c("+First Position","+Second Position",
                                                    "+Third Position","-First Position",
                                                    "-Second Position", "-Third Position"),
                                                  c("Non-Synonymous Growth Variants",
                                                    "Non-Synonymous Lipid Metabolism Variants",
                                                    "Non-Synonymous Pigmentation Variants")))

kable(synonymousMut) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

```{r}
df_list_high_g <- lapply(df_list_high_g, subset, synonymous == "n")

myFormatGenes <- function(index) {
  df_list_high_g[[index]] <- df_list_high_g[[index]][,c(3, 2, 6, 4, 5)]
}
df_list_high_g <- lapply(1:3, FUN=myFormatGenes)

#Save remaining variants to .tsv
write_tsv(df_list_high_g[[1]], "~/fast_dir/snakes/results/Growth_Gene_Variants.tsv", append=FALSE, col_names=TRUE)
write_tsv(df_list_high_g[[2]], "~/fast_dir/snakes/results/LipidMetabolism_Gene_Variants.tsv", append=FALSE, col_names=TRUE)
write_tsv(df_list_high_g[[3]], "~/fast_dir/snakes/results/Pigmentation_Gene_Variants.tsv", append=FALSE, col_names=TRUE)
```


## Variant Density Comparison

The density of variants within the genes of interest versus the density of variants within the remaining annotated genes in the Notechis scutatus assembly is investigated next. High confidence variants only are used for this comparison.

A new .bed file is created containing the locations of all genes in the Notechis scutatus assembly. This .bed file is intersected with each of the GATK, Freebayes and BCFtools .vcf files generated in the initial pre-processing.

```{r eval=FALSE}
#export gene subset to a .bed file
export.bed(genes, "~/fast_dir/snakes/targets/allGenes.bed")
```

The resulting .vcf files are converted to gds files and variants are imported into R as dataframes. They are added to a list and columns renamed.

```{r eval=FALSE}
#VCF files are converted to .gds. 
wd <- file.path("~/fast_dir/snakes/4_subset")
file.exists(wd)
gdsPath <- file.path(wd, "gds", "bcftools_allGenes.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  dir.create(dirname(gdsPath))
  file.path(wd, "vcf", "bcftools_allGenes.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
bcfGenes <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "freebayes_allGenes.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  dir.create(dirname(gdsPath))
  file.path(wd, "vcf", "freebayes_allGenes.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
freebayesGenes <- seqOpen(gdsPath, readonly = FALSE)

gdsPath <- file.path(wd, "gds", "gatk_allGenes.gds")
makeGds <- !file.exists(gdsPath)
if (makeGds) {
  dir.create(dirname(gdsPath))
  file.path(wd, "vcf", "gatk_allGenes.vcf") %>%
    seqVCF2GDS(gdsPath, reference = "GCF_900518725.1_TS10Xv2")
}
gatkGenes <- seqOpen(gdsPath, readonly = FALSE)

#Create dataframes from gds files
df_freebayesGenes <- tibble(
    seqGetData(freebayesGenes,"variant.id"),
    seqGetData(freebayesGenes, "position"),
    seqGetData(freebayesGenes, "chromosome"),
    seqGetData(freebayesGenes, "allele"),
    seqGetData(freebayesGenes, "annotation/info/DP"))

df_gatkGenes <- tibble(
    seqGetData(gatkGenes,"variant.id"),
    seqGetData(gatkGenes, "position"),
    seqGetData(gatkGenes, "chromosome"),
    seqGetData(gatkGenes, "allele"),
    seqGetData(gatkGenes, "annotation/info/DP"))

df_bcfGenes <- tibble(
    seqGetData(bcfGenes,"variant.id"),
    seqGetData(bcfGenes, "position"),
    seqGetData(bcfGenes, "chromosome"),
    seqGetData(bcfGenes, "allele"),
    seqGetData(bcfGenes, "annotation/info/DP"))

df_list_allGenes <- list(df_freebayesGenes,df_gatkGenes,df_bcfGenes)

colnames <- c("variant.id","start","scaffold","allele","DP")
df_list_allGenes <- (lapply(df_list_allGenes, setNames, colnames))
```

Variants are then filtered using the same criteria as for filtering variants in the genes of interest and high confidence variants are identified. 

```{r eval=FALSE}
#Remove variants with DP less than 15 and greater than 85
myFilter <- function(index) {
  dplyr::filter(df_list_allGenes[[index]], DP >= 15 & DP <= 85)
}
df_list_allGenes <- lapply(1:3, FUN=myFilter)

#Split rows with two alternative alleles into two rows
myRowSplitter2 <- function(index) {
  alts <- subset(df_list_allGenes[[index]], str_count(allele, ",") > 1)
  df_list_allGenes[[index]] <- df_list_allGenes[[index]][(str_count(df_list_allGenes[[index]]$allele, ",") == 1),]
  alts <- alts[rep(seq_len(nrow(alts)), each = 2),]
  count = 1
  while(count <= nrow(alts)){
    str <- strsplit(alts[[count,4]], ",")
    alts[count,'allele'] <- paste(str[[1]][1], str[[1]][2], sep = ",") 
    alts[count+1,'allele'] <- paste(str[[1]][1], str[[1]][3], sep = ",")
    count = count + 2
  }
  df_list_allGenes[[index]] <- rbind(df_list_allGenes[[index]],alts)  
}

df_list_allGenes <- lapply(1:3, FUN=myRowSplitter2)

#to intersect based on start, scaffold, and allele make a new temporary column (start+scaff+all) 
myUnite <- function(index) {
  unite(df_list_allGenes[[index]], "start_scaff_all", start:allele, remove=FALSE)
}
df_list_allGenes <- lapply(1:3, FUN=myUnite)

#intersect all three gene sets to find high confidence snps
df_allGenes <- match_df(match_df(df_list_allGenes[[1]], df_list_allGenes[[2]], on="start_scaff_all"),df_list_allGenes[[3]], on="start_scaff_all")

```

```{r echo=FALSE}
load("~/fast_dir/snakes/allGenes.RData")
```

Variant Density can then be calculated. The density of variants within the genes of interest is compared with the density of variants within the remaining annotated genes. 

```{r}
#Total length of all genes
all_gene_length <- (sum(width(genes)))

#Total variants in all genes
all_gene_variants <- nrow(unique(df_allGenes[c("start","scaffold")]))

#Total length of the genes of interest
our_gene_length <- (sum(width(growth_set))+ sum(width(lipid_set))+ sum(width(pigmentation_set)))

#Total variants within the genes of interest is calculated earlier.

#variants/ourGenes
our_genes_variant_density <-our_gene_variants/(our_gene_length/1000)

#variants/remaining genes
rem_genes_variant_density <- ((all_gene_variants-our_gene_variants)/((all_gene_length-our_gene_length)/1000))

```

We find that there are `r round(our_genes_variant_density, digits=2)` variants per kbp within the genes of interest compared with `r round(rem_genes_variant_density, digits=2)` variants per kbp within the remaining genes. 

A Fishers Exact Test is then used to determine whether this difference is significant. To do this, a table is constructed as shown below where all bases within the genes of interest and the remaining genes are categorised as 'Variant' or 'Not Variant'. We then test whether the density of variants in genes of interest vs the remaining genes is non-random. 

```{r echo=FALSE}
#We construct a matrix to match the matrix shown above. 
fishertable <- matrix(c(our_gene_variants,
                        all_gene_variants-our_gene_variants,
                        our_gene_length-our_gene_variants,
                        all_gene_length-our_gene_length-all_gene_variants),
                      nrow=2,
                      dimnames = list(c("Genes of Interest", "Remaining Genes"),
                                      c("Variant", "Not Variant")))
  
kable(fishertable) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)

fisherExact <- fisher.test(fishertable)
```

Based on a calculated p-value of `r formatC(fisherExact$p.value, format = "e", digits = 2)` and a significance level of $\alpha = 0.05$, we reject the null hypothesis. 

This indicates that there is a significant difference between variant density in the genes of interest when compared with variant density in the remaining genes. 

### Limitations

Finding the intersection of variants from three different variant callers resulted in only SNPs remaining in the high-confidence sets. Because of this, it is assumed that no indels are present in the Island Tiger Snake CDS regions. If true indels were discarded during this process and are located in the CDS regions of the genes of interest, this would alter the interpretation of which variants impact amino acid coding.

# Summary

The table below summarises the number of high confidence variants identified. 


```{r echo=FALSE}
allVariants <- matrix(c(nrow(df_list_high_p[[1]]),
                          nrow(df_list_high_g[[1]]),
                          nrow(df_list_high_p[[2]]),
                          nrow(df_list_high_g[[2]]),
                          nrow(df_list_high_p[[3]]),
                          nrow(df_list_high_g[[3]])),
                          nrow=2, dimnames = list(c("Variants in promoters",
                                                    "Variants impacting coding"),
                                                  c("Growth",
                                                    "Lipid Metabolism",
                                                    "Pigmentation")))

kable(allVariants) %>%
  kable_styling(bootstrap_options = "striped", full_width = F)
```

In addition, variant density within the genes of interest was found to be greater than variant density in the remaining annotated genes. This difference was statistically significant. 

# Session Info

```{r echo=FALSE}
sessionInfo()
```
